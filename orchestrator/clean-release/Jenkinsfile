#!/usr/bin/groovy
@NonCPS
def jsonParser(def json) {
    new groovy.json.JsonSlurperClassic().parse(json)
}

@NonCPS
def createBasicAuthString(credentials) {
    def authString = credentials.getBytes().encodeBase64().toString();
    [Authorization: "Basic " + authString]
}

def doClean(taskID, project, action, isInParallel) {

   def entity_name = ""
   def container_run_option = ""
   def docker_command = ""
   def docker_inspect_command = ""

   // Create the right command to run in the container
   if (action == "clean-all"){
        // TODO
        //  docker ps -a --filter="name=juzu"
   } else if (action == "clean-containers"){
       entity_name = "${taskID}-${project.name}"
       docker_command = "rm -f"
       docker_inspect_command = "inspect -f '{{ .Created }}'"
   } else if (action == "clean-volumes"){
       entity_name = "${taskID}-${project.name}-workspace"
       docker_command = "volume rm"
       docker_inspect_command = "volume inspect -f '{{ .CreatedAt }}'"
   }

   stage ("[CLEAN] project ${project.name} for ${taskID}") {
       def createdAt = sh (returnStdout: true, script: "sudo docker ${docker_inspect_command} ${entity_name} 2>/dev/null || :").trim()
       if (!!createdAt) {
            echo "Dropping ${entity_name}. its creation date: ${createdAt}." 
            sh "sudo docker ${docker_command} ${entity_name}"
       } else {
            echo "Warning: ${entity_name} does not exist!." 
       }
   }
}

def doCleans(taskID, projectsToClean, action, isInParallel, catalogCredentialsId) {

    def catalogURL = "${CATALOG_BASE_URL}/${TASK_ID}.json"

    def catalogRequestParameters = [:]
    def withCatalogCredentials = false
    if (catalogCredentialsId) {
        withCredentials([usernamePassword(credentialsId: catalogCredentialsId, usernameVariable: 'USER', passwordVariable: 'PASSWORD')]) {
            catalogRequestParameters += createBasicAuthString("${USER}:${PASSWORD}")
        }
        withCatalogCredentials = true
    }
    echo "Downloading catalog at ${catalogURL} withCredentials=${withCatalogCredentials}"

    def JSONCatalog = new URL(catalogURL)
    def catalog = jsonParser(JSONCatalog.newReader(requestProperties: catalogRequestParameters))    
    echo "Number of Projects in Catalog: " + catalog.size()
    // Loop first on projectsToClean to keep the order
    for (i = 0; i < projectsToClean.length; i++) {
         def projectName = projectsToClean[i];
         boolean cleanAll = false
         if (projectName.equals('*')){
             cleanAll = true
         }
         for (j = 0; j < catalog.size(); j++) {
             if (catalog[j].name == projectName || cleanAll) {
                doClean(taskID, catalog[j], action, isInParallel)
             }
         }
    }
}

// Execute Release cleanup on all Jenkins Slave with docker label
def nodes = [:]
nodesByLabel('docker').each {
    nodes[it] = { ->
        node(it) {
            def taskID = "${TASK_ID}"
            def action = "${ACTION}"
            def p = "${PROJECTS}"
            def projectsToClean = p.split(',')
            def isInParallel = true
            def catalogCredentialsId = env.CATALOG_CREDENTIALS_ID ?: ''

            // Init parameters
            stage ("Init clean parameters") {
                echo "* Projects: ${PROJECTS}"
                echo "* Command: ${ACTION}"
                echo "* Projects: ${PROJECTS}"
                echo "* CredentialsId: ${catalogCredentialsId}: "
            }

            stage ("[START] Clean for ${TASK_ID}") {
                doCleans(taskID, projectsToClean, action, isInParallel, catalogCredentialsId)
            }
        }
    }
}
parallel nodes