#!/usr/bin/groovy
@NonCPS
def jsonParser(def json) {
    new groovy.json.JsonSlurperClassic().parse(json)
}

@NonCPS
def createBasicAuthString(credentials) {
    def authString = credentials.getBytes().encodeBase64().toString();
    [Authorization: "Basic " + authString]
}

def doClean(taskID, project, action, isInParallel) {

   def volume_name = "${taskID}-${project.name}-workspace"
   def entity-name = ""
   def container_run_option = ""
   def docker_command = ""
   def docker_inspect_command = ""

   // Create the right command to run in the container
   if (action == "clean-all"){
        // TODO
        //  docker ps -a --filter="name=juzu"
   } else if (action == "clean-containers"){
       entity-name = "${taskID}-${project.name}"
       docker_command = "rm -f"
       docker_inspect_command = "inspect -f '{{ .Created }}'"
   } else if (action == "clean-volumes"){
       entity-name = "${taskID}-${project.name}-workspace"
       docker_command = "volume rm"
       docker_inspect_command = "volume inspect -f '{{ .CreatedAt }}'"
   }

   stage ("[CLEAN] project ${project.name} for ${taskID}") {
       def createdAt = sh (returnStdout: true, script: "sudo docker ${docker_inspect_command} ${entity-name} || :").trim()
       if (!!createdAt) {
            echo "Dropping ${entity-name}. its creation date: ${createdAt}." 
            sh "sudo docker ${docker_command} ${entity-name}"
       } else {
            echo "Warning: ${entity-name} does not exist!." 
       }
   }
}

def doCleans(taskID, projectsToClean, action, isInParallel, catalogCredentialsId) {

    def catalogURL = "${CATALOG_BASE_URL}/${TASK_ID}.json"

    def catalogRequestParameters = [:]
    def withCatalogCredentials = false
    if (catalogCredentialsId) {
        withCredentials([usernamePassword(credentialsId: catalogCredentialsId, usernameVariable: 'USER', passwordVariable: 'PASSWORD')]) {
            catalogRequestParameters += createBasicAuthString("${USER}:${PASSWORD}")
        }
        withCatalogCredentials = true
    }
    echo "Downloading catalog at ${catalogURL} withCredentials=${withCatalogCredentials}"

    def JSONCatalog = new URL(catalogURL)
    def catalog = jsonParser(JSONCatalog.newReader(requestProperties: catalogRequestParameters))    
    echo "Number of Projects in Catalog: " + catalog.size()
    // Loop first on projectsToClean to keep the order
    for (i = 0; i < projectsToClean.length; i++) {
         def projectName = projectsToClean[i];
         boolean cleanAll = false
         if (projectName.equals('*')){
             cleanAll = true
         }
         for (j = 0; j < catalog.size(); j++) {
             if (catalog[j].name == projectName || cleanAll) {
                doClean(taskID, catalog[j], action, isInParallel)
             }
         }
    }
}

// Execute Release on Jenkins Slave with Docker
node('docker') {

  def taskID = "${TASK_ID}"
  def action = "${ACTION}"
  def p = "${PROJECTS}"
  def projectsToClean = p.split(',')
  def isInParallel = true
  def catalogCredentialsId = env.CATALOG_CREDENTIALS_ID ?: ''
  
  // Init parameters
  stage ("Init clean parameters") {
    echo "* Projects: ${PROJECTS}"
    echo "* Command: ${ACTION}"
    echo "* Projects: ${PROJECTS}"
    echo "* CredentialsId: ${catalogCredentialsId}: "
  }

  stage ("[START] Clean for ${TASK_ID}") {
    doCleans(taskID, projectsToClean, action, isInParallel, catalogCredentialsId)
  }
}
