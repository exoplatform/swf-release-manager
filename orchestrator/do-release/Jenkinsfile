#!/usr/bin/groovy
@NonCPS
def jsonParser(def json) {
    new groovy.json.JsonSlurperClassic().parse(json)
}

def doRelease(exoUser, jenkinsAgentRootPath, jiraID, project, releaseCMD, isInParallel) {

   def volume_name = "${jiraID}-${project.name}-workspace"
   def container_name = "${jiraID}-${project.name}"
   def container_run_option = ""
   def docker_image = "${project.container.image}"

   // Create the right command to run in the container
   if (releaseCMD == "start"){
        echo "Create volume ${volume_name}"
        sh "sudo docker volume create --name=${volume_name}"
        container_command = "release-start ${project.name} ${jiraID}"
   } else if (releaseCMD == "validate"){
       container_command = "release-validate ${jiraID}"
   } else if (releaseCMD == "cancel"){
       container_command = "release-cancel ${project.name} ${jiraID}" 
   } else if (releaseCMD == "catalog-from-url"){
       container_command = "catalog-from-url ${jiraID}"
   } else if (releaseCMD == "release-continue-from nexus:create"){
       container_command = "release-continue-from nexus:create"
   } else if (releaseCMD == "release-continue-from nexus:deploy"){
       container_command = "release-continue-from nexus:deploy"
   } else if (releaseCMD == "release-continue-from nexus:close"){
       container_command = "release-continue-from nexus:close"
   } else {
       echo "Nothing to do."
   }

   if (isInParallel == "true"){
       container_run_option = "-d"
   }

   stage("Container ${container_name}"){
        sh "sudo docker run --rm ${container_run_option} -v /${jenkinsAgentRootPath}/.gnupg/pubring.gpg:/home/ciagent/.gnupg/pubring.gpg:ro \
                -v /${jenkinsAgentRootPath}/.gnupg/secring.gpg:/home/ciagent/.gnupg/secring.gpg:ro \
                -v /${jenkinsAgentRootPath}/.gnupg/gpg.conf:/home/ciagent/.gnupg/gpg.conf:ro \
                -v /${jenkinsAgentRootPath}/.ssh/id_rsa:/home/ciagent/.ssh/id_rsa:ro \
                --env-file /${jenkinsAgentRootPath}/.eXo/Release/exo-release.properties \
                -e exo_user=${exoUser} \
                -e CATALOG_BASE_URL=${CATALOG_BASE_URL} \
                -v ${volume_name}:/opt/exo-release/workspace \
                -v ${jiraID}-m2_cache:/home/ciagent/.m2/repository \
                --name ${container_name} \
                ${docker_image} \
                \"${container_command}\""
    }

    //RELMAN-3:
    if (releaseCMD == "cancel"){
        stage("Container ${container_name} (cleanup)"){
            sh "sudo docker volume rm ${volume_name}"
            sh "sudo docker volume rm ${jiraID}-m2_cache"
        }
    }
    
}

// Read data from JSON Catalog and executes an action on the specified projects
def executeActionOnProjects(projects, action) {

    def JSONCatalog = new URL("${CATALOG_BASE_URL}/${JIRA_ID}.json")
    def catalog = jsonParser(JSONCatalog.newReader())

    echo "Number of Projects in Catalog: ${catalog.size}"
    // Loop first on projectsToRelease to keep the order
    for (i = 0; i < projects.length; i++) {
        def projectName = projects[i];
        for (j = 0; j < catalog.size; j++) {
            if (catalog[j].name == projectName) {
                action(catalog[j])
            }
        }
    }
}

def validateProjectsToRelease(projects) {
  def valid = true
  // Map containing the projects found in the catalog and the number of actions performed
  def releasedProjects = [:]
  def releasedProjectCounter = { project -> 
    def name = project.name
    releasedProjects[name] = releasedProjects.containsKey(name) ? releasedProjects[name]+1 : 1
  }
  
  executeActionOnProjects(projects, releasedProjectCounter)
  
  // check if  all the projects were found on the json
  def unreleasedProjects = projects - releasedProjects.keySet()
  if(unreleasedProjects.length > 0) {
    echo "ERROR The project(s) ${unreleasedProjects} were not found in the catalog file."
    valid = false
  }
  // Check if no project was present several times on the json
  def duplicates = releasedProjects.findAll({ it.value > 1 }).keySet()
  if(duplicates) {
    echo "ERROR The project(s) ${duplicates} are released several times or are present several times on the json file."
    valide = false
  }
  valid
}

// Execute Release on Jenkins Slave with Docker
node('docker') {

  // Init parameters
  stage "Check Release parameters"
  def jiraID = "${JIRA_ID}"
  def releaseCMD = "${RELEASE_CMD}"
  def p = "${PROJECTS}"
  def projectsToRelease = p.split(',')
  def isInParallel = "${RELEASE_PROJECTS_IN_PARALLEL}"
  def jenkinsAgentRootPath = "${JENKINS_AGENT_ROOT_PATH}"
  def exoUser = "${BUILD_USER_ID}"
  echo "* Projects: ${PROJECTS}"
  echo "* Projects computed: ${projectsToRelease}"
  echo "* Command: ${RELEASE_CMD}"
  echo "* Projects: ${PROJECTS}"
  echo "* Releases in Parallel? ${isInParallel}"

  stage "${JIRA_ID}-projects_validation"
  if ( ! validateProjectsToRelease(projectsToRelease) ) {
    currentBuild.result = "FAIL"
    return
  }

  //Create m2 cache volume for the release
  stage "${JIRA_ID}-m2_cache"
  sh "sudo docker volume create --name ${JIRA_ID}-m2_cache"

  stage "${JIRA_ID}-do_release"
  executeActionOnProjects(projectsToRelease, { project ->
    doRelease(exoUser, jenkinsAgentRootPath, jiraID, project, releaseCMD, isInParallel)
  })
}
